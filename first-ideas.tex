\documentclass{article}

\newcommand{\hide}[1]{}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{datetime}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage{quiver}
\usepackage{stmaryrd}
\usepackage{tikz-cd}
\usepackage{tikz}

\usepackage{listings}
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
%  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
%  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
%  breaklines=true,                 % sets automatic line breaking
%  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\itshape\rmfamily\color{gray},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
%  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
%  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle= \sffamily,       % keyword style
  identifierstyle=\rmfamily\itshape,
  language=haskell,                 % the language of the code
  basicstyle=\sffamily\upshape,
%  morekeywords=[2]{knight,bernoulli},            % if you want to add more keywords to the set
%  keywordstyle=[2]\itshape\bfseries,       % keyword style
%  morekeywords=[3]{Prob,uniform,bernoulli,normal,beta,exponential},            % if you want to add more keywords to the set
%  keywordstyle=[3]\color{mygreen},       % keyword style
%  numbers=left,                    % where to put the line numbers; possible values are (none, left, right)
%  numbersep=5pt,                   % how far the line numbers are from the code
%  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
%  rulecolor=\color{black},         % if not set, the frame colour may be changed on line breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
%  stepnumber=2,                    % the step between two line numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
%  tabsize=2,	                   % sets default tab size to 2 spaces
%  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
 literate={->}{$\rightarrow\;$}{2}
 {<-}{$\leftarrow\;$}{2}
}

\newtheorem{thm}{Theorem}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{claim}[thm]{Claim}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\newtheorem{question}[thm]{Question}

\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}

\newcommand{\MCA}{\ensuremath{\mathcal A}}
\newcommand{\MCB}{\ensuremath{\mathcal B}}
\newcommand{\MCC}{\ensuremath{\mathcal C}}
\newcommand{\MCD}{\ensuremath{\mathcal D}}
\newcommand{\MCE}{\ensuremath{\mathcal E}}
\newcommand{\MCF}{\ensuremath{\mathcal F}}
\newcommand{\MCG}{\ensuremath{\mathcal G}}
\newcommand{\MCH}{\ensuremath{\mathcal H}}
\newcommand{\MCI}{\ensuremath{\mathcal I}}
\newcommand{\MCJ}{\ensuremath{\mathcal J}}
\newcommand{\MCK}{\ensuremath{\mathcal K}}
\newcommand{\MCL}{\ensuremath{\mathcal L}}
\newcommand{\MCM}{\ensuremath{\mathcal M}}
\newcommand{\MCN}{\ensuremath{\mathcal N}}
\newcommand{\MCO}{\ensuremath{\mathcal O}}
\newcommand{\MCP}{\ensuremath{\mathcal P}}
\newcommand{\MCQ}{\ensuremath{\mathcal Q}}
\newcommand{\MCR}{\ensuremath{\mathcal R}}
\newcommand{\MCS}{\ensuremath{\mathcal S}}
\newcommand{\MCT}{\ensuremath{\mathcal T}}
\newcommand{\MCU}{\ensuremath{\mathcal U}}
\newcommand{\MCV}{\ensuremath{\mathcal V}}
\newcommand{\MCW}{\ensuremath{\mathcal W}}
\newcommand{\MCX}{\ensuremath{\mathcal X}}
\newcommand{\MCY}{\ensuremath{\mathcal Y}}
\newcommand{\MCZ}{\ensuremath{\mathcal Z}}

\newcommand{\BA}{\ensuremath{\mathbb A}}
\newcommand{\BB}{\ensuremath{\mathbb B}}
\newcommand{\BC}{\ensuremath{\mathbb C}}
\newcommand{\BD}{\ensuremath{\mathbb D}}
\newcommand{\BE}{\ensuremath{\mathbb E}}
\newcommand{\BF}{\ensuremath{\mathbb F}}
\newcommand{\BG}{\ensuremath{\mathbb G}}
\newcommand{\BH}{\ensuremath{\mathbb H}}
\newcommand{\BI}{\ensuremath{\mathbb I}}
\newcommand{\BJ}{\ensuremath{\mathbb J}}
\newcommand{\BK}{\ensuremath{\mathbb K}}
\newcommand{\BL}{\ensuremath{\mathbb L}}
\newcommand{\BM}{\ensuremath{\mathbb M}}
\newcommand{\BN}{\ensuremath{\mathbb N}}
\newcommand{\BO}{\ensuremath{\mathbb O}}
\newcommand{\BP}{\ensuremath{\mathbb P}}
\newcommand{\BQ}{\ensuremath{\mathbb Q}}
\newcommand{\BR}{\ensuremath{\mathbb R}}
\newcommand{\BS}{\ensuremath{\mathbb S}}
\newcommand{\BT}{\ensuremath{\mathbb T}}
\newcommand{\BU}{\ensuremath{\mathbb U}}
\newcommand{\BV}{\ensuremath{\mathbb V}}
\newcommand{\BW}{\ensuremath{\mathbb W}}
\newcommand{\BX}{\ensuremath{\mathbb X}}
\newcommand{\BY}{\ensuremath{\mathbb Y}}
\newcommand{\BZ}{\ensuremath{\mathbb Z}}

\ddmmyyyydate
\renewcommand{\dateseparator}{-}

\makeatletter
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\large \textbf \@title \par}%
    \vskip 1.5em%
    {
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author
      \end{tabular}\par}%
    \vskip 1em%
    {Draft of \@date}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

\newcommand{\todo}[1]{[Todo: #1]}

\DeclareMathOperator*{\colim}{colim}

\newcommand{\op}{^{\mathrm{op}}}
\newcommand{\Kl}{\mathrm{Kl}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\FinSet}{\mathbf{FinSet}}
\newcommand{\CCat}{\mathcal{C}}
\newcommand{\DCat}{\mathcal{D}}
\newcommand{\GCat}{\mathcal{G}}

\newcommand{\bind}{\mathrel{\scalebox{0.5}[1]{$>\!>=$}}}
\newcommand{\ob}[1]{{|#1|}}

\newcommand{\mult}{\phi}
\newcommand{\unit}{\eta}

\newcommand{\Idm}[1]{\mathsf{Idm}(#1)}

\title{Notes on idioms}
\author{Jack Liell-Cock, Theo Wang}
\date{\today}

\begin{document}

\maketitle

The following can be defined at the generality of monoidal categories. However, this seems like overkill for the applications in mind.
We should at the very most consider symmetric monoidal closed categories but probably easiest to consider Cartesian closed categories.

\begin{defn}
  Let $\CCat$ be a monidal category. An \emph{idiom} is a pointed lax monoidal endofunctor on $\CCat$.
  That is, an idiom $(J, \unit, \varepsilon, \mult)$ consists of:
  \begin{itemize}
    \item An endofunctor $J: \CCat \to \CCat$,
    \item A family of maps $\unit_A: A \to JA$ natural in $A \in \CCat$,
    \item A map $\varepsilon: 1 \to J1$,
    \item A family of maps $\mult_{A,B}: JA \times JB \to J(A\times B)$ natural in $A,B \in \CCat$,
  \end{itemize}
  such that the following diagrams commute.
  \begin{mathpar}
    \begin{tikzcd}[column sep=large]
      {(JA\times JB)\times JC} & {J(A\times B) \times JC} & {J((A\times B)\times C)} \\
      {JA\times (JB\times JC)} & {JA\times J(B\times C)} & {J(A\times (B\times C))}
      \arrow["{\phi_{A,B}\times JC}", from=1-1, to=1-2]
      \arrow["{\alpha_{JA,JB,JC}}"', from=1-1, to=2-1]
      \arrow["{\phi_{A\times B, C}}", from=1-2, to=1-3]
      \arrow["{J\alpha_{A,B,C}}", from=1-3, to=2-3]
      \arrow["{JA\times \phi_{B,C}}"', from=2-1, to=2-2]
      \arrow["{\phi_{A,B\times C}}"', from=2-2, to=2-3]
    \end{tikzcd}
    \and
    \begin{tikzcd}[column sep=large]
      {1\times JA} & {J1 \times JA} \\
      JA & {J(1\times A)}
      \arrow["{\varepsilon \times JA}", from=1-1, to=1-2]
      \arrow["{\lambda_{JA}}"', from=1-1, to=2-1]
      \arrow["{\phi_{A,1}}", from=1-2, to=2-2]
      \arrow["{J\lambda_A}", from=2-2, to=2-1]
    \end{tikzcd}
    \and
    \begin{tikzcd}[column sep=large]
      {A\times B} & {JA\times JB} \\
      & {J(A\times B)}
      \arrow["{\eta_A\times \eta_B}", from=1-1, to=1-2]
      \arrow["{\eta_{A\times B}}"', from=1-1, to=2-2]
      \arrow["{\phi_{A,B}}", from=1-2, to=2-2]
    \end{tikzcd}
    \and
    \begin{tikzcd}
      1 \\
      & J1
      \arrow["\varepsilon"', curve={height=12pt}, from=1-1, to=2-2]
      \arrow["{\eta_1}", curve={height=-12pt}, from=1-1, to=2-2]
    \end{tikzcd}
  \end{mathpar}
  The coherences imply that $\varepsilon = \unit_1$, so we often elide it.
\end{defn}

Idioms can be categorically presented as \emph{strong} lax monoidal functors~\cite{mcbride-applicatives}.
The following proposition links this presentation to the above definition. It seems like folklore, but I haven't seen it written down anywhere.
Kock~\cite{kock-strong-functors} proves part of this result (pointed lax monoidal implies strong lax monoidal) but not the reverse direction.
The benefits of the above definition is that there are way fewer coherence diagrams to check.
Also, it aligns with the data of applicatives in Haskell way more closely.

\begin{prop}
  Let $\CCat$ be a monidal category. The following data are equivalent:
  \begin{enumerate}
    \item A lax monoidal endofunctor $(J, \varepsilon, \phi): \CCat \to \CCat$ with monoidal pointedness $\eta_A: A \to JA$.
      In particular, the following diagrams commute.
      \begin{mathpar}
        \begin{tikzcd}[column sep=large]
          {A\otimes B} & {JA\otimes JB} \\
          & {J(A\otimes B)}
          \arrow["{\eta_A\otimes \eta_B}", from=1-1, to=1-2]
          \arrow["{\eta_{A\otimes B}}"', from=1-1, to=2-2]
          \arrow["{\phi_{A,B}}", from=1-2, to=2-2]
        \end{tikzcd}
        \and
        \begin{tikzcd}
          I \\
          & JI
          \arrow["\varepsilon"', curve={height=12pt}, from=1-1, to=2-2]
          \arrow["{\eta_I}", curve={height=-12pt}, from=1-1, to=2-2]
        \end{tikzcd}
      \end{mathpar}
    \item A lax monoidal endofunctor $(J, \varepsilon, \phi): \CCat \to \CCat$ with monoidal bistrength $\sigma^l_{A,B}, \sigma^r_{A,B}$.
      In particular, the following diagrams commute.
      \begin{mathpar}
        \begin{tikzcd}[column sep=large]
          {(A\otimes JB)\otimes JC} & {J(A\otimes B)\otimes JC} & {J((A\otimes B)\otimes C)} \\
          {A\otimes (JB\otimes JC)} & {A\otimes J(B\otimes C)} & {J(A\otimes (B\otimes C))}
          \arrow["{\sigma^l_{A,B}\otimes JC}", from=1-1, to=1-2]
          \arrow["{\alpha_{A,JB,JC}}"', from=1-1, to=2-1]
          \arrow["{\phi_{A\otimes B, C}}", from=1-2, to=1-3]
          \arrow["{J\alpha_{A,B,C}}", from=1-3, to=2-3]
          \arrow["{A\otimes \phi_{B,C}}"', from=2-1, to=2-2]
          \arrow["{\sigma^l_{A,B\otimes C}}"', from=2-2, to=2-3]
        \end{tikzcd}
        \and
        \begin{tikzcd}[column sep=large]
          {(JA\otimes JB)\otimes C} & {J(A\otimes B) \otimes C} & {J((A\otimes B)\otimes C)} \\
          {JA\otimes (JB\otimes C)} & {JA\otimes J(B\otimes C)} & {J(A\otimes (B\otimes C))}
          \arrow["{\phi_{A,B}\otimes C}", from=1-1, to=1-2]
          \arrow["{\alpha_{JA,JB,C}}"', from=1-1, to=2-1]
          \arrow["{\sigma^r_{A\otimes B, C}}", from=1-2, to=1-3]
          \arrow["{J\alpha_{A,B,C}}", from=1-3, to=2-3]
          \arrow["{JA\otimes \sigma^r_{B,C}}"', from=2-1, to=2-2]
          \arrow["{\phi_{A,B\otimes C}}"', from=2-2, to=2-3]
        \end{tikzcd}
      \end{mathpar}
  \end{enumerate}
\end{prop}

\begin{proof}
  In the forwards direction, we define
  \begin{align*}
    \sigma^l_{A,B}: &A \otimes JB \xrightarrow{\eta_A \otimes JB} JA \otimes JB \xrightarrow{\phi_{A,B}} J(A\otimes B), \\
    \sigma^r_{A,B}: &JA \otimes B \xrightarrow{JA \otimes \eta_B} JA \otimes JB \xrightarrow{\phi_{A,B}} J(A\otimes B).
  \end{align*}
  In the reverse direction, we define
  \[
    \eta_A: A \xrightarrow{\lambda_A^{-1}} I \otimes A \xrightarrow{\varepsilon \otimes A} JI \otimes A \xrightarrow{\sigma^r_{I,A}} J(I\otimes A) \xrightarrow{J\lambda_A} JA.
  \]
  Note that this is equivalent to defining
  \[
    \eta_A: A \xrightarrow{\rho_A^{-1}} A \otimes I \xrightarrow{A \otimes \varepsilon} A \otimes JI \xrightarrow{\sigma^l_{A,I}} J(A \otimes I) \xrightarrow{J\rho_A} JA.
  \]
  The coherences lift through correspondingly.
\end{proof}

\paragraph{Enrichment for free}

\begin{prop}
Let $\CCat$ be a Cartesian closed category. Given an idiom $(J_0, \unit, \mult)$ on $\CCat$,
there is a $\CCat$-enriched functor $J : \CCat \to \CCat$ that has same mapping on objects
as $J_0$, and its mapping on hom-objects $J_{A,B}: [A,B] \to [JA, JB]$ is given by the transpose of:
\[
  [A,B] \times JA \xrightarrow{\unit_{[A,B]} \times JA} J[A,B] \times JA \xrightarrow{\mult_{[A,B], A}} J([A,B] \times A) \xrightarrow{J\mathsf{ev}_{A,B}} JB
\]
Moreover, $J$ is enriched pointed lax monoidal, and so is an enriched idiom.
\end{prop}

\begin{proof}
  \todo{For Theo to prove.}
\end{proof}

\paragraph{The idiom category}

The goal of this section is to define a Kleisli-like category for idioms.
In the sense that Kleisli categories of monads capture programs with monadic effects, we would like the Kleisli-like category to capture programs with idiomatic effects.

\begin{defn}
  For a Cartesian closed category $\CCat$ considered self-enriched, and an idiom $(J, \unit, \mult)$.
  We define the category $\Idm J$ as the image of the category $\CCat$ under the change of base along $J$.
  That is,
  \begin{mathpar}
    \ob {\Idm J} = \ob \CCat
    \and
    \Idm J [A, B] = J[A,B].
  \end{mathpar}
\end{defn}

\begin{prop}
  The $\CCat$-enriched functor $J: \CCat \to \CCat$ decomposes into
  \[
    J: \CCat \xrightarrow{L} \Idm J \xrightarrow{R} \CCat,
  \]
  where $L$ is defined as
  \begin{mathpar}
    LA = A, \and L_{A,B}(f) = \eta_{[A,B]}(f),
  \end{mathpar}
  and $R$ is defined as
  \begin{mathpar}
    RA = JA, \and R_{A,B}(f) = \lambda a.W(\mathsf{ev})(\phi_{[A,B], A}(f, a)),
  \end{mathpar}
\end{prop}

\begin{question}
  Is this decomposition universal in some way? Much like the way the Kleisli category is the initial resolution of the monad.
\end{question}

The category $\Idm J$ seems to be a nice category to do idiomatic computations in, because morphisms are effectful, but cant be sequenced based on their return value.

\begin{prop}
  The category $\Idm J$ is symmetric monoidal closed, and $L$ is a symmetric monoidal closed functor.
\end{prop}

\begin{proof}
  \todo{Prove}
\end{proof}

\paragraph{The idiom calculus}

\newcommand{\aj}[3]{#1 \vdash_{\mathsf{v}} #2:#3}
\newcommand{\cj}[3]{#1 \vdash_{\mathsf{c}} #2:#3}
\newcommand{\lunit}{{*}}
\newcommand{\app}[2]{{#1 \ #2}}
\newcommand{\lift}[1]{\mathsf{lift}(#1)}

We begin with value judgements (judgements in $\CCat$) which follow the simply-typed lambda calculus:
\begin{mathpar}
  \inferrule{ }{\aj {\Gamma,a:A,\Gamma'} a {A}}
  \and
  \inferrule{ }{\aj {\Gamma} \lunit {1}}
  \and
  \inferrule{\aj \Gamma u {A\times B}}{\aj \Gamma {\pi_1 u} {A}}
  \and
  \inferrule{\aj \Gamma u {A\times B}}{\aj \Gamma {\pi_2 u} {B}}
  \and
  \inferrule{\aj {\Gamma} u {A} \and \aj {\Gamma} v {B}}{\aj {\Gamma} {(u,v)} {A\times B}}
  \and
  \inferrule{\aj {\Gamma,a:A} u B}{\aj \Gamma {\lambda (a:A).u} {A\to B}}
  \and
  \inferrule{\aj \Gamma u {A\to B} \and \aj \Gamma v A}{\aj \Gamma {\app u v} B}
\end{mathpar}
We may \emph{lift} value judgements to computation judgements (in the idiomatic sense), which corresponds to applying $\unit$ to the him-object.
\begin{mathpar}
  \inferrule{\aj \Gamma t A}{\cj \Gamma {\lift t} A}
\end{mathpar}

Given the category $\Idm J$ is symmetric monoidal closed, we use the linear lambda calculus for computation judgements.
We additionally request that $\mathsf{lift}$ is a symmetric monoidal closed functor, in correspondence with $L$.
For instance,
\begin{mathpar}
  \inferrule{\aj \Gamma u {A\to B} \and \aj \Gamma v A}{\cj \Gamma {\app {\lift u} {\lift v} = {\lift{\app u v}}} B}
\end{mathpar}
For each operator of our idiom, $\sigma : A$, it may be introduced via the following judgement.
\begin{mathpar}
  \inferrule{ }{\cj \bullet {\underline{\sigma}} A}
\end{mathpar}

\begin{question}
  Can we find a syntax that is sound and complete for $\Idm J$? What about $R$? Can we develop this further to accommodate the full ``appjuncion'' like as in CBPV?
\end{question}

\paragraph{Example with zip}

\newcommand{\List}{\mathsf{List}_\omega}
\newcommand{\pure}{\mathsf{pure}}
\newcommand{\zip}{\mathsf{zip}}

The zip idiom is defined as $(\List, \pure, \zip)$ where, in Haskell notation:
\begin{lstlisting}
pure :: a -> [a]
pure x = [x,x,..]

zip :: ([a], [b]) -> [(a, b)]
zip (x:xs, y:ys) = (x,y):zip (xs, ys)
zip ([], _)      = []
zip (_, [])      = []
\end{lstlisting}
We may give a presentation of this idiom as an operator $\underline{n} = [*,\dots, *]$ of length $n$ for $n\in \mathbb{N}$ and an operator $\underline{\omega} = [1,2,\dots]$.
See Sean's note for further details.
These are subject to the following equations:
\begin{mathpar}
  \List(\lambda x.(x,x))(\mult(\underline{n}, \underline{m})) = (\underline{\min(n, m)}, \underline{\min(n, m)})
  \and
  \pure(x) = \List(\lambda \_.x)(\underline{\omega})
\end{mathpar}
We can build the following program:
\[
  \cj {f:\mathbb{N} \to A} {\lift{\lambda x. f(\pi_1(x))}(\underline{\omega}, \underline{3})} A
\]
The intuition of this program is that it first generates all \emph{worlds} and enumerates them using $\underline{\omega}$.
The function $f:\mathbb{N}\to A$ performs some action based on that world. However, the operation $\underline{3}$ kills all worlds above enumeration $3$.

\bibliography{refs}
\bibliographystyle{plainurl}

\end{document}
