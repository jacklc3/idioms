\documentclass{article}

\newcommand{\hide}[1]{}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{datetime}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage{quiver}
\usepackage{stmaryrd}
\usepackage{tikz-cd}
\usepackage{tikz}
\usepackage{cleveref}

\usepackage{listings}
\lstset{
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
%  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
%  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
%  breaklines=true,                 % sets automatic line breaking
%  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\itshape\rmfamily\color{gray},    % comment style
%  deletekeywords={...},            % if you want to delete keywords from the given language
%  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
%  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  firstnumber=1000,                % start line enumeration with line 1000
%  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle= \sffamily,       % keyword style
  identifierstyle=\rmfamily\itshape,
  language=haskell,                 % the language of the code
  basicstyle=\sffamily\upshape,
%  morekeywords=[2]{knight,bernoulli},            % if you want to add more keywords to the set
%  keywordstyle=[2]\itshape\bfseries,       % keyword style
%  morekeywords=[3]{Prob,uniform,bernoulli,normal,beta,exponential},            % if you want to add more keywords to the set
%  keywordstyle=[3]\color{mygreen},       % keyword style
%  numbers=left,                    % where to put the line numbers; possible values are (none, left, right)
%  numbersep=5pt,                   % how far the line numbers are from the code
%  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
%  rulecolor=\color{black},         % if not set, the frame colour may be changed on line breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
%  stepnumber=2,                    % the step between two line numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
%  tabsize=2,	                   % sets default tab size to 2 spaces
%  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
 literate={->}{$\rightarrow\;$}{2}
 {<-}{$\leftarrow\;$}{2}
}

\newcommand{\mlstinline}[1]{\mbox{\lstinline|#1|}}

\newtheorem{thm}{Theorem}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{claim}[thm]{Claim}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{example}[thm]{Example}
\newtheorem{question}[thm]{Question}

\theoremstyle{remark}
\newtheorem{remark}[thm]{Remark}

\newcommand{\MCA}{\ensuremath{\mathcal A}}
\newcommand{\MCB}{\ensuremath{\mathcal B}}
\newcommand{\MCC}{\ensuremath{\mathcal C}}
\newcommand{\MCD}{\ensuremath{\mathcal D}}
\newcommand{\MCE}{\ensuremath{\mathcal E}}
\newcommand{\MCF}{\ensuremath{\mathcal F}}
\newcommand{\MCG}{\ensuremath{\mathcal G}}
\newcommand{\MCH}{\ensuremath{\mathcal H}}
\newcommand{\MCI}{\ensuremath{\mathcal I}}
\newcommand{\MCJ}{\ensuremath{\mathcal J}}
\newcommand{\MCK}{\ensuremath{\mathcal K}}
\newcommand{\MCL}{\ensuremath{\mathcal L}}
\newcommand{\MCM}{\ensuremath{\mathcal M}}
\newcommand{\MCN}{\ensuremath{\mathcal N}}
\newcommand{\MCO}{\ensuremath{\mathcal O}}
\newcommand{\MCP}{\ensuremath{\mathcal P}}
\newcommand{\MCQ}{\ensuremath{\mathcal Q}}
\newcommand{\MCR}{\ensuremath{\mathcal R}}
\newcommand{\MCS}{\ensuremath{\mathcal S}}
\newcommand{\MCT}{\ensuremath{\mathcal T}}
\newcommand{\MCU}{\ensuremath{\mathcal U}}
\newcommand{\MCV}{\ensuremath{\mathcal V}}
\newcommand{\MCW}{\ensuremath{\mathcal W}}
\newcommand{\MCX}{\ensuremath{\mathcal X}}
\newcommand{\MCY}{\ensuremath{\mathcal Y}}
\newcommand{\MCZ}{\ensuremath{\mathcal Z}}

\newcommand{\BA}{\ensuremath{\mathbb A}}
\newcommand{\BB}{\ensuremath{\mathbb B}}
\newcommand{\BC}{\ensuremath{\mathbb C}}
\newcommand{\BD}{\ensuremath{\mathbb D}}
\newcommand{\BE}{\ensuremath{\mathbb E}}
\newcommand{\BF}{\ensuremath{\mathbb F}}
\newcommand{\BG}{\ensuremath{\mathbb G}}
\newcommand{\BH}{\ensuremath{\mathbb H}}
\newcommand{\BI}{\ensuremath{\mathbb I}}
\newcommand{\BJ}{\ensuremath{\mathbb J}}
\newcommand{\BK}{\ensuremath{\mathbb K}}
\newcommand{\BL}{\ensuremath{\mathbb L}}
\newcommand{\BM}{\ensuremath{\mathbb M}}
\newcommand{\BN}{\ensuremath{\mathbb N}}
\newcommand{\BO}{\ensuremath{\mathbb O}}
\newcommand{\BP}{\ensuremath{\mathbb P}}
\newcommand{\BQ}{\ensuremath{\mathbb Q}}
\newcommand{\BR}{\ensuremath{\mathbb R}}
\newcommand{\BS}{\ensuremath{\mathbb S}}
\newcommand{\BT}{\ensuremath{\mathbb T}}
\newcommand{\BU}{\ensuremath{\mathbb U}}
\newcommand{\BV}{\ensuremath{\mathbb V}}
\newcommand{\BW}{\ensuremath{\mathbb W}}
\newcommand{\BX}{\ensuremath{\mathbb X}}
\newcommand{\BY}{\ensuremath{\mathbb Y}}
\newcommand{\BZ}{\ensuremath{\mathbb Z}}

\ddmmyyyydate
\renewcommand{\dateseparator}{-}

\makeatletter
\def\@maketitle{%
  \newpage
  \null
  \vskip 2em%
  \begin{center}%
  \let \footnote \thanks
    {\large \textbf \@title \par}%
    \vskip 1.5em%
    {
      \lineskip .5em%
      \begin{tabular}[t]{c}%
        \@author
      \end{tabular}\par}%
    \vskip 1em%
    {Draft of \@date}%
  \end{center}%
  \par
  \vskip 1.5em}
\makeatother

\newcommand{\todo}[1]{\textcolor{blue}{[TODO: #1]}}

\DeclareMathOperator*{\colim}{colim}

\newcommand{\op}{^{\mathrm{op}}}
\newcommand{\Kl}{\mathrm{Kl}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\FinSet}{\mathbf{FinSet}}
\newcommand{\CCat}{\mathcal{C}}
\newcommand{\DCat}{\mathcal{D}}
\newcommand{\GCat}{\mathcal{G}}
\newcommand{\id}{\mathsf{id}}

\newcommand{\bind}{\mathrel{\scalebox{0.5}[1]{$>\!>=$}}}
\newcommand{\ob}[1]{{|#1|}}

\newcommand{\mult}{\phi}
\newcommand{\unit}{\eta}

\newcommand{\Idm}[1]{\mathsf{Idm}(#1)}

\title{Notes on idioms}
\author{Jack Liell-Cock, Theo Wang}
\date{\today}

\begin{document}

\maketitle

\section{Idioms categorically}

The following results can be defined at the generality of (non-symmetric) monoidal/closed categories. However, this seems like overkill for the applications in mind.
It would also make the theory more convoluted with the need to analyse left and right closed structures individually.
So for now, we stick to the domain of symmetric monoidal closed categories.

\begin{defn}
  Let $(\CCat, I, [{-}, {=}], \iota, j, \psi)$ be a closed category. An \emph{idiom} is a pointed closed endofunctor on $\CCat$.
  That is, an idiom $(J, \unit, \varepsilon, \mult)$ consists of:
  \begin{itemize}
    \item An endofunctor $J: \CCat \to \CCat$,
    \item A family of maps $\unit_A: A \to JA$ natural in $A \in \CCat$,
    \item A map $\varepsilon: 1 \to J1$,
    \item A family of maps $\kappa_{A,B} : J[A,B] \to [JA,JB]$ natural in $A\in\CCat\op$ and $B \in \CCat$,
  \end{itemize}
  such that the following diagrams commute.
  \begin{mathpar}
    \begin{tikzcd}
      I & {[JA,JA]} \\
      JI & {J[A,A]}
      \arrow["{j_{JA}}", from=1-1, to=1-2]
      \arrow["\varepsilon"', from=1-1, to=2-1]
      \arrow["{Jj_A}"', from=2-1, to=2-2]
      \arrow["{\kappa_{A,A}}"', from=2-2, to=1-2]
    \end{tikzcd}
    \and
    \begin{tikzcd}
      {J[I,A]} & {[JI,JA]} \\
      JA & {[I,JA]}
      \arrow["{\kappa_{I,A}}", from=1-1, to=1-2]
      \arrow["{J\iota_A}"', from=1-1, to=2-1]
      \arrow["{[\varepsilon,JA]}", from=1-2, to=2-2]
      \arrow["{\iota^{-1}_{JA}}"', from=2-1, to=2-2]
    \end{tikzcd}
    \and
    \begin{tikzcd}[column sep=large]
      {J[B,C]} & {J[[A,B],[A,C]]} & {[J[A,B], J[A,C]]} \\
      {[JB,JC]} & {[[JA,JB],[JA,JC]]} & {[J[A,B], [JA,JC]]}
      \arrow["{J\psi^A_{B,C}}", from=1-1, to=1-2]
      \arrow["{\kappa_{B,C}}"', from=1-1, to=2-1]
      \arrow["{\kappa_{[A,B],[A,C]}}", from=1-2, to=1-3]
      \arrow["{[J[A,B], \kappa_{A,C}]}", from=1-3, to=2-3]
      \arrow["{\psi^{JA}_{JB,JC}}"', from=2-1, to=2-2]
      \arrow["{[\kappa_{A,B}, [JA,JC]]}"', from=2-2, to=2-3]
    \end{tikzcd}
    \and
    \begin{tikzcd}
      I \\
      & JI
      \arrow["\varepsilon"', curve={height=12pt}, from=1-1, to=2-2]
      \arrow["{\eta_I}", curve={height=-12pt}, from=1-1, to=2-2]
    \end{tikzcd}
    \and
    \begin{tikzcd}
      {[A,B]} & {[A,JB]} \\
      {J[A,B]} & {[JA,JB]}
      \arrow["{[A,\eta_B]}", from=1-1, to=1-2]
      \arrow["{\eta_{[A,B]}}"', from=1-1, to=2-1]
      \arrow["{\kappa_{A,B}}"', from=2-1, to=2-2]
      \arrow["{[\eta_A, JB]}"', from=2-2, to=1-2]
    \end{tikzcd}
  \end{mathpar}
  The coherences imply that $\varepsilon = \unit_1$, so we often elide it.
\end{defn}
The applicative typeclass in Haskell is the following:
\begin{lstlisting}
  class Applicative j where
    pure :: a -> j a
    ** :: j (a -> b) -> (j a -> j b)
\end{lstlisting}
They must satisfy the following laws:
\begin{lstlisting}
  pure id ** u = u
  ((pure (.) ** u) ** v) ** w = u ** (v ** w)
  pure f ** pure x = pure (f x)
  u ** pure x = pure (\f -> f x) ** u
\end{lstlisting}
We can see that the data of an applicative in Haskell is the same as the data of an idiom defined above (where $\varepsilon = \mlstinline{pure ()}$ implicitly).
Each law corresponds to one of those above (beside the trivial $\varepsilon = \eta_I$) except for the exchange law,
which when instantiating into Haskell notation gives:
\begin{lstlisting}
  u ** pure () = pure (\f -> f ()) ** u
\end{lstlisting}

\begin{question}
Given Haskell is a ``Cartesian closed category'', can we derive
\begin{lstlisting}
  u ** pure x = pure (\f -> f x) ** u
\end{lstlisting}
from
\begin{lstlisting}
  u ** pure () = pure (\f -> f ()) ** u
\end{lstlisting}
If not, which is the correct definition? In the latter case, an idiom is not simply a \emph{strong lax monoidal endofunctor}, but something slightly stronger.
\end{question}

\subsection{Relating other categorical definitions of idioms}

Idioms have also been described as \emph{strong lax monoidal functors}~\cite{mcbride-applicatives}.
The following propositions link this presentation to the above definition. It seems like folklore, but I haven't seen it properly written down anywhere.

\begin{prop} \label{prop:strong-pointed-closed}
  Let $(\CCat, I, [{-}, {=}])$ be a closed category and $(J, \varepsilon, \kappa): \CCat \to \CCat$ a lax closed endofunctor. Then, the following data are equivalent:
  \begin{enumerate}
    \item A closed natural transformation $\eta: \id_\CCat \to J$. That is, the following diagrams commute.
      \begin{mathpar}
        \begin{tikzcd}
          I \\
          & JI
          \arrow["\varepsilon"', curve={height=12pt}, from=1-1, to=2-2]
          \arrow["{\eta_I}", curve={height=-12pt}, from=1-1, to=2-2]
        \end{tikzcd}
        \and
        \begin{tikzcd}
          {[A,B]} & {[A,JB]} \\
          {J[A,B]} & {[JA,JB]}
          \arrow["{[A,\eta_B]}", from=1-1, to=1-2]
          \arrow["{\eta_{[A,B]}}"', from=1-1, to=2-1]
          \arrow["{\kappa_{A,B}}"', from=2-1, to=2-2]
          \arrow["{[\eta_A, JB]}"', from=2-2, to=1-2]
        \end{tikzcd}
      \end{mathpar}
    \item A closed strength $\theta: [{-}, {=}] \to [J{-}, J{=}]$. That is, the following diagrams commute.
      \begin{mathpar}
        \begin{tikzcd}
          {[I,[A,B]]} & {[JI, J[A,B]]} \\
          & {[I,[JA,JB]]}
          \arrow["{\theta_{I,[A,B]}}", from=1-1, to=1-2]
          \arrow["{[I,\theta_{A,B}]}"', from=1-1, to=2-2]
          \arrow["{[\varepsilon,\kappa_{A,B}]}", from=1-2, to=2-2]
        \end{tikzcd}
        \and
        \begin{tikzcd}
          I & {[A,A]} \\
          & {[JA,JA]}
          \arrow["{j_A}", from=1-1, to=1-2]
          \arrow["{j_{JA}}"', from=1-1, to=2-2]
          \arrow["{\theta_{A,A}}", from=1-2, to=2-2]
        \end{tikzcd}
        \and
        \begin{tikzcd}
          {[B,C]} & {[JB,JC]} & {[[JA,JB],[JA,JC]]} \\
          {[[A,B],[A,C]]} && {[[A,B],[JA,JC]]}
          \arrow["{\theta_{B,C}}", from=1-1, to=1-2]
          \arrow["{\psi^A_{B,C}}"', from=1-1, to=2-1]
          \arrow["{\psi^{JA}_{JB,JC}}", from=1-2, to=1-3]
          \arrow["{[\theta_{A,B},[JA,JC]]}", from=1-3, to=2-3]
          \arrow["{[[A,B],\theta_{A,C}]}"', from=2-1, to=2-3]
        \end{tikzcd}
      \end{mathpar}
  \end{enumerate}
\end{prop}

\begin{proof}
  In the forwards direction, we define:
  \[
    \theta_{A,B}: [A,B] \xrightarrow{\eta_{[A,B]}} J[A,B] \xrightarrow{\kappa_{A,B}} [JA,JB]
  \]
  In the reverse direction, we define:
  \[
    \eta_A : A \xrightarrow{\iota^{-1}_A} [I,A] \xrightarrow{\theta_{I,A}} [JI,JA] \xrightarrow{[\varepsilon, JA]} [I,JA] \xrightarrow{\iota_{JA}} JA
  \]
  The equations follow from a diagram chase.
\end{proof}

This result states that idioms are also described by \emph{strong lax closed endofunctors}.
A theorem of Kock gives the correspondence between strong lax closed endofunctors and strong lax monoidal endofunctors when $\CCat$ is a symmetric monoidal closed category,
which formally aligns the commonly stated folklore that an idion is just a \emph{strong lax monoidal endofunctor}.

\begin{prop}[\cite{kock-strong-functors}] \label{prop:strong-monoidal-closed}
  Let $(\CCat, I, \otimes, [{-},{=}])$ be a symmetric monoidal closed category and $J: \CCat \to \CCat$ an endofunctor.
  Then, the following are equivalent:
  \begin{enumerate}
    \item The data to make $J$ a strong lax monoidal functor.
    \item The data to make $J$ a strong lax closed functor.
  \end{enumerate}
\end{prop}
\todo{J: I'm not sure Kock actually proved this for coherences between the coherence conditions of strength. We may need to show this ourselves.}

We may close the following diagram in the symmetric monoidal closed case with a final proposition.
\[
  \begin{tikzcd}
    {\text{Strong lax closed}} & {\text{Strong lax monoidal}} \\
    {\text{Pointed lax closed}} & {\text{Pointed lax monoidal}}
    \arrow["\cong"{description}, draw=none, from=1-1, to=1-2]
    \arrow["\cong"{description}, draw=none, from=1-1, to=2-1]
    \arrow["\cong"{description}, draw=none, from=1-2, to=2-2]
    \arrow["\cong"{description}, draw=none, from=2-1, to=2-2]
  \end{tikzcd}
\]
The benefits of this final presentation over the strong lax monoidal presentation is that there are fewer coherence diagrams to check.

\begin{prop} \label{prop:strong-pointed-monoidal}
  Let $(\CCat, I, \otimes)$ be a symmetric monoidal category and $(J, \varepsilon, \phi): \CCat \to \CCat$ a lax monoidal endofunctor.
  Then, the following data are equivalent:
  \begin{enumerate}
    \item A monoidal natural transformation $\eta: \id_\CCat \to J$. That is, the following diagrams commute.
      \begin{mathpar}
        \begin{tikzcd}
          I \\
          & JI
          \arrow["\varepsilon"', curve={height=12pt}, from=1-1, to=2-2]
          \arrow["{\eta_I}", curve={height=-12pt}, from=1-1, to=2-2]
        \end{tikzcd}
        \and
        \begin{tikzcd}[column sep=large]
          {A\otimes B} & {JA\otimes JB} \\
          & {J(A\otimes B)}
          \arrow["{\eta_A\otimes \eta_B}", from=1-1, to=1-2]
          \arrow["{\eta_{A\otimes B}}"', from=1-1, to=2-2]
          \arrow["{\phi_{A,B}}", from=1-2, to=2-2]
        \end{tikzcd}
      \end{mathpar}
    \item A monoidal tensorial strength $\theta: ({-} \otimes J{=}) \to J({-}\otimes {=})$. That is, the following diagram commutes.
      \begin{mathpar}
        \begin{tikzcd}[column sep=large]
          {(A\otimes JB)\otimes JC} & {J(A\otimes B)\otimes JC} & {J((A\otimes B)\otimes C)} \\
          {A\otimes (JB\otimes JC)} & {A\otimes J(B\otimes C)} & {J(A\otimes (B\otimes C))}
          \arrow["{\theta_{A,B}\otimes JC}", from=1-1, to=1-2]
          \arrow["{\alpha_{A,JB,JC}}"', from=1-1, to=2-1]
          \arrow["{\phi_{A\otimes B, C}}", from=1-2, to=1-3]
          \arrow["{J\alpha_{A,B,C}}", from=1-3, to=2-3]
          \arrow["{A\otimes \phi_{B,C}}"', from=2-1, to=2-2]
          \arrow["{\theta_{A,B\otimes C}}"', from=2-2, to=2-3]
        \end{tikzcd}
      \end{mathpar}
  \end{enumerate}
\end{prop}

\begin{proof}
  In the forwards direction, we define:
  \[
    \theta_{A,B}: A \otimes JB \xrightarrow{\eta_A \otimes JB} JA \otimes JB \xrightarrow{\phi_{A,B}} J(A\otimes B)
  \]
  In the reverse direction, we define:
  \[
    \eta_A: A \xrightarrow{\rho_A^{-1}} A \otimes I \xrightarrow{A \otimes \varepsilon} A \otimes JI \xrightarrow{\theta_{A,I}} J(A \otimes I) \xrightarrow{J\rho_A} JA.
  \]
  The coherences lift through correspondingly.
\end{proof}

\subsection{Enrichment for free}

Any idiom is an enriched idiom.

\begin{prop}
  Let $\CCat$ be a Cartesian closed category. Given an idiom $(J_0, \unit, \kappa)$ on $\CCat$,
  there is a $\CCat$-enriched functor $J : \CCat \to \CCat$ that has same mapping on objects
  as $J_0$, and its mapping on hom-objects is $J_{A,B} = \kappa_{A,B}: [A,B] \to [JA, JB]$.

  Moreover, $J$ is enriched pointed lax monoidal, and so is an enriched idiom.
\end{prop}

\begin{proof}
  For the purpose of this proof, it is easier to consider $J_0$ equivalently as a strong lax monoidal functor by \Cref{prop:strong-pointed-monoidal}. Then, as shown by \cite{kock-strong-functors}, $J$ is automatically a $\CCat$-enriched functor by the definition above. In particular, one can easily check that $J$ and $J_0$ have the same action on morphisms, i.e. for every $f: A \to B$: 
  \[
  \begin{tikzcd}
    I && {[A,B]} \\
    && {[JA, JB]}
    \arrow["{cur(f\circ \lambda^{-1})}", from=1-1, to=1-3]
    \arrow["{cur(J_0(f)\circ \lambda^{-1})}"', from=1-1, to=2-3]
    \arrow["{J_{A,B}}", from=1-3, to=2-3]
  \end{tikzcd}
  \]
  It remains to show that $J$ is enriched pointed lax monoidal.
  For this, it suffices to take the transpose of $\eta$ and $\phi$ and prove that the adequate diagrams commute.
  \todo{Theo to prove this. Elementary proof shouldn't be hard but does this follow from abstract nonsense?}
\end{proof}

\section{The idiom category}

The goal of this section is to define a Kleisli-like category for idioms.
In the sense that Kleisli categories of monads capture programs with monadic effects, we would like the Kleisli-like category to capture programs with idiomatic effects.

\begin{defn}
  For a Cartesian closed category $\CCat$ considered self-enriched, and an idiom $(J, \unit, \mult)$.
  We define the category $\Idm J$ as the image of the category $\CCat$ under the change of base along $J$.
  That is,
  \begin{mathpar}
    \ob {\Idm J} = \ob \CCat,
    \and
    \Idm J (A, B) = J[A,B].
  \end{mathpar}
\end{defn}

\begin{prop}
  The $\CCat$-enriched functor $J: \CCat \to \CCat$ decomposes into
  \[
    J: \CCat \xrightarrow{L} \Idm J \xrightarrow{R} \CCat,
  \]
  where $L$ is defined as
  \begin{mathpar}
    LA = A, \and L_{A,B}(f) = \eta_{[A,B]}(f),
  \end{mathpar}
  and $R$ is defined as
  \begin{mathpar}
    RA = JA, \and R_{A,B}(f) = \lambda a.W(\mathsf{ev})(\phi_{[A,B], A}(f, a)),
  \end{mathpar}
\end{prop}

\begin{question}
  Is this decomposition universal in some way? Much like the way the Kleisli category is the initial resolution of the monad.
\end{question}

The category $\Idm J$ seems to be a nice category to do idiomatic computations in, because morphisms are effectful, but can't be sequenced based on their return value.

\begin{prop}
  The category $\Idm J$ is symmetric monoidal closed, and $L$ is a symmetric monoidal closed functor.
\end{prop}

\begin{proof}
  \todo{Prove}
\end{proof}

\subsection{Relating the idiom category to the Kleisli category}

In Haskell, a (strong) monad is also an idiom. Mathematically, let $\CCat$ be cartesian closed.
Then, any strong monad $(T, \eta, \mu, \theta)$ (equivalently a $\CCat$-enriched monad) over $\CCat$ is also a pointed lax monoidal functor,
with the point given as the return and the lax multiplication defined as the composite,
\[
  \phi_{A,B}: TA \times TB \xrightarrow{\tilde\theta_{A,TB}} T(A \times TB) \xrightarrow{T\theta_{A,B}} TT(A \times B) \xrightarrow{\mu_{A\times B}} T(A\times B),
\]
where $\tilde\theta_{A,B} : TA \times B \to T(A\times B)$ is the right strength given by the symmetry of the CCC.
Note, we can define a second lax multiplication by chaining the strengths in the opposite order,
and these composites are equal if and only if $T$ is commutative~\cite{kock-strong-functors}.

It is easy to define a $\CCat$-enriched functor $F: \Idm{T} \to \Kl(T)$ which is identity on objects and has its action on morphism $F_{A, B}$ defined as the following composition:
\[
  T[A, B] \xrightarrow{} [TA, TB] \xrightarrow{[\eta_A, TB]} [A, TB]
\]
where the first arrow is exactly the same as $R_{A, B}$ (this corresponds to the \texttt{<*>} operation in the Haskell interface).

\begin{prop}
  In the following diagram, $F \circ L = L'$ and $R' \circ F = R$.
  \[
  \begin{tikzcd}
    {\Idm{T}} && {\Kl(T)} \\
    \\
    & \CCat
    \arrow["F", from=1-1, to=1-3]
    \arrow["R", shift left, curve={height=-6pt}, from=1-1, to=3-2]
    \arrow[""{name=0, anchor=center, inner sep=0}, "{R'}", shift left=3, curve={height=-6pt}, from=1-3, to=3-2]
    \arrow["L", curve={height=-6pt}, from=3-2, to=1-1]
    \arrow[""{name=1, anchor=center, inner sep=0}, "{L'}", shift right, curve={height=-6pt}, from=3-2, to=1-3]
    \arrow["\dashv"{anchor=center, rotate=-20}, shift left, draw=none, from=1, to=0]
  \end{tikzcd}
  \]
\end{prop}
\begin{proof}
  \todo{Prove}
\end{proof}

\begin{question}
  Do $\Idm{T}$ and $\Kl(T)$ relate in more interesting ways via $F$? Can this lead to a universal property for $\Idm{T}$?
\end{question}

Theoretical questions aside, this presentation could help express the relationship between idiomatic and monadic computation. Haskell already uses it in its \texttt{ApplicativeDo} language option \cite{marlow-applicative-do}, which allows the Haskell compiler to elaborate do-notations into idiomatic (applicative) computations instead of monadic ones when the full power of the monad is not necessary (e.g. no branching based on previous inputs).  

\begin{question}
  How do our constructions relate to \texttt{ApplicativeDo}? 
\end{question}

\section{The idiom calculus}

\newcommand{\aj}[3]{#1 \vdash_{\mathsf{v}} #2:#3}
\newcommand{\cj}[3]{#1 \vdash_{\mathsf{c}} #2:#3}
\newcommand{\lunit}{{*}}
\newcommand{\app}[2]{{#1 \ #2}}
\newcommand{\lift}[1]{\mathsf{lift}(#1)}

We begin with value judgements (judgements in $\CCat$) which follow the simply-typed lambda calculus:
\begin{mathpar}
  \inferrule{ }{\aj {\Gamma,a:A,\Gamma'} a {A}}
  \and
  \inferrule{ }{\aj {\Gamma} \lunit {1}}
  \and
  \inferrule{\aj \Gamma u {A\times B}}{\aj \Gamma {\pi_1 u} {A}}
  \and
  \inferrule{\aj \Gamma u {A\times B}}{\aj \Gamma {\pi_2 u} {B}}
  \and
  \inferrule{\aj {\Gamma} u {A} \and \aj {\Gamma} v {B}}{\aj {\Gamma} {(u,v)} {A\times B}}
  \and
  \inferrule{\aj {\Gamma,a:A} u B}{\aj \Gamma {\lambda (a:A).u} {A\to B}}
  \and
  \inferrule{\aj \Gamma u {A\to B} \and \aj \Gamma v A}{\aj \Gamma {\app u v} B}
\end{mathpar}
We may \emph{lift} value judgements to computation judgements (in the idiomatic sense), which corresponds to applying $\unit$ to the hom-object.
\begin{mathpar}
  \inferrule{\aj \Gamma t A}{\cj \Gamma {\lift t} A}
\end{mathpar}

Given the category $\Idm J$ is symmetric monoidal closed, we use the linear lambda calculus for computation judgements.
We additionally request that $\mathsf{lift}$ is a symmetric monoidal closed functor, in correspondence with $L$.
For instance,
\begin{mathpar}
  \inferrule{\aj \Gamma u {A\to B} \and \aj \Gamma v A}{\cj \Gamma {\app {\lift u} {\lift v} = {\lift{\app u v}}} B}
\end{mathpar}
For each operator of our idiom, $\sigma : A$, it may be introduced via the following judgement.
\begin{mathpar}
  \inferrule{ }{\cj \bullet {\underline{\sigma}} A}
\end{mathpar}

\begin{question}
  Can we find a syntax that is sound and complete for $\Idm J$? What about $R$? Can we develop this further to accommodate the full ``appjuncion'' like as in CBPV?
\end{question}

\subsection{Example with zip}

\newcommand{\List}{\mathsf{List}_\omega}
\newcommand{\pure}{\mathsf{pure}}
\newcommand{\zip}{\mathsf{zip}}

The zip idiom is defined as $(\List, \pure, \zip)$ where, in Haskell notation:
\begin{lstlisting}
pure :: a -> [a]
pure x = [x,x,..]

zip :: ([a], [b]) -> [(a, b)]
zip (x:xs, y:ys) = (x,y):zip (xs, ys)
zip ([], _)      = []
zip (_, [])      = []
\end{lstlisting}
We may give a presentation of this idiom as an operator $\underline{n} = [*,\dots, *]$ of length $n$ for $n\in \mathbb{N}$ and an operator $\underline{\omega} = [1,2,\dots]$.
See Sean's note for further details.
These are subject to the following equations:
\begin{mathpar}
  \List(\lambda x.(x,x))(\mult(\underline{n}, \underline{m})) = (\underline{\min(n, m)}, \underline{\min(n, m)})
  \and
  \pure(x) = \List(\lambda \_.x)(\underline{\omega})
\end{mathpar}
We can build the following program:
\[
  \cj {f:\mathbb{N} \to A} {\lift{\lambda x. f(\pi_1(x))}(\underline{\omega}, \underline{3})} A
\]
The intuition of this program is that it first generates all \emph{worlds} and enumerates them using $\underline{\omega}$.
The function $f:\mathbb{N}\to A$ performs some action based on that world. However, the operation $\underline{3}$ kills all worlds above enumeration $3$.

\bibliography{refs}
\bibliographystyle{plainurl}

\end{document}
